/*****************************************************************************\

* Function:    cliTask

* Input:       void *arg  ... unused

* Returns:     void

* Description:

*     This function is the inifite loop for the command line intepreter.. it

*     reads characters using the FreeRTOS_read function then sends them to the

*     cli when there is a \r

\*****************************************************************************/
#include "cmsis_os.h"
#include "FreeRTOS_CLI.h"
#include "command_line_functions.h"
#include "task.h"

#define INTRO_STRING "Command Line & RTC Demo\n"
#define MAX_INPUT_LENGTH    50
//#define MAX_OUTPUT_LENGTH   configCOMMAND_INT_MAX_OUTPUT_SIZE
#define MAX_OUTPUT_LENGTH   128

// Send VT100 Clear Screen and Home Escape Codes
#define VT100_CLEARSCREEN "\033[2J\033[H"
inline void clearScreen()
{
    FreeRTOS_write(0,VT100_CLEARSCREEN,strlen(VT100_CLEARSCREEN));
}



static const CLI_Command_Definition_t clearCommandStruct =

    {

        "clear",

        "clear: Clear Screen by sending VT100 Escape Code\n",

        clearCommand,

        0

    };





void cliTask(void *arg)

{
    (void)arg;

    char pcOutputString[ MAX_OUTPUT_LENGTH ], pcInputString[ MAX_INPUT_LENGTH ];

    int8_t cRxedChar, cInputIndex = 0;

    BaseType_t xMoreDataToFollow;

    FreeRTOS_open( (const int8_t *)"/uart",0 );
    clearScreen();
    FreeRTOS_write(0,INTRO_STRING,strlen(INTRO_STRING));
    FreeRTOS_CLIRegisterCommand( &clearCommandStruct );
    while(1)
    {
        FreeRTOS_read( 0, &cRxedChar, sizeof( cRxedChar ) );
        if( cRxedChar == '\r' )
        {
            /* A newline character was received, so the input command string is
            complete and can be processed.  Transmit a line separator, just to
            make the output easier to read. */

            FreeRTOS_write(0,&cRxedChar,1);

            /* The command interpreter is called repeatedly until it returns
            pdFALSE.  See the "Implementing a command" documentation for an
            exaplanation of why this is. */

            do

            {

                /* Send the command string to the command interpreter.  Any
                output generated by the command interpreter will be placed in the
                pcOutputString buffer. */
                xMoreDataToFollow = FreeRTOS_CLIProcessCommand

                              (

                                  pcInputString,   /* The command string.*/
                                  pcOutputString,  /* The output buffer. */
                                  MAX_OUTPUT_LENGTH/* The size of the output buffer. */
                              );

                /* Write the output generated by the command interpreter to the
                console. */
                FreeRTOS_write( 0, pcOutputString, strlen( pcOutputString ) );

            } while( xMoreDataToFollow != pdFALSE );

            /* All the strings generated by the input command have been sent.
            Processing of the command is complete.  Clear the input string ready
            to receive the next command. */
            cInputIndex = 0;
            memset( pcInputString, 0x00, MAX_INPUT_LENGTH );
        }

        else

        {

            /* The if() clause performs the processing after a newline character
            is received.  This else clause performs the processing if any other
            character is received. */
            if( cRxedChar == 127 ) // delete character

            {
                FreeRTOS_write(0,&cRxedChar,1);

                /* Backspace was pressed.  Erase the last character in the input
                buffer - if there are any. */

                if( cInputIndex > 0 )
                {
                    cInputIndex--;
                    pcInputString[ cInputIndex ] = '\0';
                }
            }

            else
            {
                /* A character was entered.  It was not a new line, backspace
                or carriage return, so it is accepted as part of the input and
                placed into the input buffer.  When a \n is entered the complete
                string will be passed to the command interpreter. */
                if( cInputIndex < MAX_INPUT_LENGTH )
                {
                    FreeRTOS_write(0,&cRxedChar,1);
                    pcInputString[ cInputIndex ] = cRxedChar;
                    cInputIndex++;
                }
            }
        }
    }
}

/*****************************************************************************\
* Function:    clearCommand
* Input:       char *pcWriteBufer,size_t xWriteBufferLen,const char *pcCommandString
* Returns:     BaseType_t
* Description:
*     This function clears the screen. It is run by the CLI interpreter
\*****************************************************************************/

BaseType_t clearCommand( char *pcWriteBuffer,size_t xWriteBufferLen, const char *pcCommandString )

{
    (void)pcCommandString;
    static int processed = 0;
    char *clearScreen = VT100_CLEARSCREEN;
    // Only allowed to write up top xWriteBufferLen bytes ...
    strncpy(pcWriteBuffer,&clearScreen[processed],xWriteBufferLen-1);
    pcWriteBuffer[xWriteBufferLen-1]=0;
    processed = processed + xWriteBufferLen-1;
    if(processed < (int)strlen(clearScreen))
        return pdTRUE;

    processed = 0;
    return pdFALSE;
}

