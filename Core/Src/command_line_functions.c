/*
 * command_line_functions.c
 *
 *  Created on: Feb 10, 2020
 *      Author: s3rf
 */

/*Example 1: A command with no parameters*/

#include "command_line_functions.h"
#include "cmsis_os.h"
#include "FreeRTOS_CLI.h"
#include "task.h"




static BaseType_t prvTaskStatsCommand( int8_t *pcWriteBuffer,
                                          size_t xWriteBufferLen,
                                          const int8_t *pcCommandString )
{
    /* For simplicity, this function assumes the output buffer is large enough
    to hold all the text generated by executing the vTaskList() API function,
    so the xWriteBufferLen parameter is not used. */
    ( void ) xWriteBufferLen;

    /* pcWriteBuffer is used directly as the vTaskList() parameter, so the table
    generated by executing vTaskList() is written directly into the output
    buffer. */
    vTaskList( pcWriteBuffer + strlen( pcHeader ) );

    /* The entire table was written directly to the output buffer.  Execution
    of this command is complete, so return pdFALSE. */
    return pdFALSE;
}

/*Example 2: Returning multiple lines one line at a time */
/* This function implements the behaviour of a command, so must have the correct
prototype. */
static BaseType_t prvHelpCommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString ){
	/* Executing the “help” command will generate multiple lines of text, but this
	function will only output a single line at a time.  Therefore, this function is
	called multiple times to complete the processing of a single “help” command.  That
	means it has to remember which help strings it has already output, and which
	still remain to be output.  The static pxCommand variable is used to point to the
	next help string that needs outputting. */
	static const xCommandLineInputListItem *pxCommand = NULL;
	signed BaseType_t xReturn;

		if( pxCommand == NULL )
		{
			/* pxCommand is NULL in between executions of the “help” command, so if
			it is NULL on entry to this function it is the start of a new “help” command
			and the first help string is returned.  The following line points pxCommand
			to the first command registered with FreeRTOS+CLI. */
			pxCommand = &xRegisteredCommands;
		}

		/* Output the help string for the command pointed to by pxCommand, taking
		care not to overflow the output buffer. */
		strncpy( pcWriteBuffer,
				 pxCommand->pxCommandLineDefinition->pcHelpString,
				 xWriteBufferLen );

		/* Move onto the next command in the list, ready to output the help string
		for that command the next time this function is called. */
		pxCommand = pxCommand->pxNext;

		if( pxCommand == NULL )
		{
			/* If the next command in the list is NULL, then there are no more
			commands to process, and pdFALSE can be returned. */
			xReturn = pdFALSE;
		}
		else
		{
			/* If the next command in the list is not NULL, then there are more
			commands to process and therefore more lines of output to be generated.
			In this case pdTRUE is returned. */
			xReturn = pdTRUE;
		}

    return xReturn;
}




/*Example 3: A command with a fixed number of parameters*/

/* This function implements the behaviour of a command, so must have the correct
prototype. */
static BaseType_t prvCopyCommand( int8_t *pcWriteBuffer,
                                     size_t xWriteBufferLen,
                                     const int8_t *pcCommandString )
{
int8_t *pcParameter1, *pcParameter2;
BaseType_t xParameter1StringLength, xParameter2StringLength, xResult;

    /* Obtain the name of the source file, and the length of its name, from
    the command string. The name of the source file is the first parameter. */
    pcParameter1 = FreeRTOS_CLIGetParameter
                        (
                          /* The command string itself. */
                          pcCommandString,
                          /* Return the first parameter. */
                          1,
                          /* Store the parameter string length. */
                          &xParameter1StringLength
                        );

    /* Obtain the name of the destination file, and the length of its name. */
    pcParameter2 = FreeRTOS_CLIGetParameter( pcCommandString,
                                             2,
                                             &xParameter2StringLength );

    /* Terminate both file names. */
    pcParameter1[ xParameter1StringLength ] = 0x00;
    pcParameter2[ xParameter2StringLength ] = 0x00;

    /* Perform the copy operation itself. */
    xResult = prvCopyFile( pcParameter1, pcParameter2 );

    if( xResult == pdPASS )
    {
        /* The copy was successful.  There is nothing to output. */
        *pcWriteBuffer = NULL;
    }
    else
    {
        /* The copy was not successful.  Inform the users. */
        snprintf( pcWriteBuffer, xWriteBufferLen, "Error during copyrnrn" );
    }

    /* There is only a single line of output produced in all cases.  pdFALSE is
    returned because there is no more output to be generated. */
    return pdFALSE;
}

/*Example 4: A command with a variable number of parameters*/
static BaseType_t prvParameterEchoCommand(int8_t *pcWriteBuffer,size_t xWriteBufferLen, const int8_t *pcCommandString ){

	int8_t *pcParameter;
	BaseType_t lParameterStringLength, xReturn;

	/* Note that the use of the static parameter means this function is not reentrant. */
	static BaseType_t lParameterNumber = 0;

		if( lParameterNumber == 0 )
		{
			/* lParameterNumber is 0, so this is the first time the function has been
			called since the command was entered.  Return the string “The parameters
			were:” before returning any parameter strings. */
			sprintf( pcWriteBuffer, "The parameters were:rn" );

			/* Next time the function is called the first parameter will be echoed
			back. */
			lParameterNumber = 1L;

			/* There is more data to be returned as no parameters have been echoed
			back yet, so set xReturn to pdPASS so the function will be called again. */
			xReturn = pdPASS;
		}
		else
		{
			/* lParameter is not 0, so holds the number of the parameter that should
			be returned.  Obtain the complete parameter string. */
			pcParameter = ( int8_t * ) FreeRTOS_CLIGetParameter
										(
											/* The command string itself. */
											pcCommandString,
											/* Return the next parameter. */
											lParameterNumber,
											/* Store the parameter string length. */
											&lParameterStringLength
										);

			if( pcParameter != NULL )
			{
				/* There was another parameter to return.  Copy it into pcWriteBuffer.
				in the format “[number]: [Parameter String”. */
				memset( pcWriteBuffer, 0x00, xWriteBufferLen );
				sprintf( pcWriteBuffer, "%d: ", lParameterNumber );
				strncat( pcWriteBuffer, pcParameter, lParameterStringLength );
				strncat( pcWriteBuffer, "rn", strlen( "rn" ) );

				/* There might be more parameters to return after this one, so again
				set xReturn to pdTRUE. */
				xReturn = pdTRUE;
				lParameterNumber++;
			}
			else
			{
				/* No more parameters were found.  Make sure the write buffer does
				not contain a valid string to prevent junk being printed out. */
				pcWriteBuffer[ 0 ] = 0x00;

				/* There is no more data to return, so this time set xReturn to
				pdFALSE. */
				xReturn = pdFALSE;

				/* Start over the next time this command is executed. */
				lParameterNumber = 0;
			}
		}

    return xReturn;
}

/*****************************************************************************\

* Function:    clearCommand

* Input:       char *pcWriteBufer,size_t xWriteBufferLen,const char *pcCommandString

* Returns:     BaseType_t

* Description:

*     This function clears the screen. It is run by the CLI interpreter

\*****************************************************************************/



BaseType_t clearCommand( char *pcWriteBuffer,size_t xWriteBufferLen, const char *pcCommandString )

{

    (void)pcCommandString;

    static int processed = 0;



    char *clearScreen = VT100_CLEARSCREEN;

    // Only allowed to write up top xWriteBufferLen bytes ...

    strncpy(pcWriteBuffer,&clearScreen[processed],xWriteBufferLen-1);

    pcWriteBuffer[xWriteBufferLen-1]=0;



    processed = processed + xWriteBufferLen-1;

    if(processed < (int)strlen(clearScreen))

        return pdTRUE;



    processed = 0;

    return pdFALSE;

}
